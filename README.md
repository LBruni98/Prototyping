# Prototyping

## 1. Prototyping Functionality and End User Requirements

### 1.1 Different Prototypes
A Prototype is a basic version of a product or system, that showcases and demonstrates how the system or product will work. Prototypes within software development are used as a base for the final product, to which it is continuously tested and reworked until a satisfactory prototype is created which the original complete product or system can be developed using this final prototype.

There are many variants of prototypes that are used for different aspects of the development of the initial system, either generating the idea for the product, used for understanding the features contained within the system or as stated above, building off of the prototype to help aid in the final creation of the complete system or product.

##### 1.1.2 Wireframe Prototype
A Wireframe Prototype is where the product is presented as a skeleton. This is done with quick images or illustrations that capture the initial idea of the product, including design, layout and structure.

##### 1.1.3 Feasibility Prototype
A feasibility prototype is created to determine how feasible the various solutions included are and are mainly used to help eliminate most of the technical risks that will come up within development, such as performance, component compatibility, optimization, etc.

##### 1.1.4 Horizontal Prototype
A Horizontal Prototype is a prototype used for showing off a diverse range of features that are planned to be used in the system but not fully implemented the features. These types of prototypes are used for showcasing the range of abilities that are included in a system.

##### 1.1.5 Vertical Prototype
A Vertical Prototype is used only for certain, smaller features that will be used in a system, showcased near-completed.

##### 1.1.6 Functional Storyboarding
A storyboard is used to create an early layout of the product, mainly before the development of the system. This describes the product like a story and presents the information in a readable and more understandable way to that of the development team[2][3].

### 1.2 End User Testing
End User Testing or User Acceptance testing is a phase during the testing of a product where users have a hand in testing the product to help stand up to actual scenarios that the product might face. This testing is crucial before the whole product goes on the market. It is essentially a “real-world” test where the user interacts with the system as normal, investigating the features and find out if there isn’t anything overlooked, left out, understood poorly and such.

The objective of End User Testing is for the product to be able to work alongside day to day life along with regular use, to ensure that the system is up to the business needs[4].

##### 1.2.1 Alpha and Beta Testing
Alpha testing is done normally by the developers during the project’s development, carried out to recognize the bugs and current issues in the system before the initial product is moved out. This type of testing is carried out fairly early in the products lifecycle, near the end of development and before beta testing is carried out. Once the feedback from this testing has been reported, the developers can rework and improve the product for the next cycle or release.

Beta Testing is done via a customer environment, by customers that use the system as if they were going about it regularly. With beta testing, it allows users to fully experience the product and allows for them to locate the issues or bugs that are found in the near complete system. Once tested, the users provide feedback that allows for developers to further improve the product before its release.

##### 1.2.2 Contract Testing
The software in question is tested to a set of criteria and specifications which are agreed upon in a contract. This contract will only result in payment if the requirements that have been specified have been met by the product.

##### 1.2.3 Regulation Testing
With regulation testing, the software is tested against rules and regulations that are defined by the government of a country where the development is being based at and even released. Should the product violate any of these rules and regulations imposed by the country, the product won’t be allowed to use and distribute the product, ultimately deeming it a failure.

##### 1.2.4 Operation Testing
Operation testing is mainly carried out to make sure that implement workflows to ensure the product or system to be used. The workflows tested are for recovery and system backups, training, security and various other workflows to ensure stability of the system before it gets released.

##### 1.2.5 Black Box
Black Box, though functional, can be perceived as end user as well, as these tests share the same properties as End User Testing. This testing is executed to analyse the functionalities of the product or system.

The user doesn’t see the original source code but only the base product. Error reports are noted within the certain categories, outlining missing functions, errors and other issues, etc. This sort of testing is prominent within development because of the equivalents to End User Testing[5].

### 1.3 Reviewing Prototyping forms
##### 1.3.1 Wireframe Prototype
Wireframes are considered to be low-fidelity mock-ups that’s purposes are to display the layout of an interface or webpage, giving the outline or conveying the direction and description of said interface or webpage. They aren’t really proper prototypes but rather a simple representation of what a system would look like, whereas prototypes would have more in terms of detail, content or even function to represent what the final product would look like[6].

As such, they would only be okay for laying down the foundations of what the product would look like or its overall foundation, but shouldn’t be used for anything greater, such as the entire basis for the actual product. More medium to high fidelity prototypes should be used in terms of development, refinement and testing as well as design and function.

##### 1.3.2 Feasibility Prototype
A feasibility prototype is used to establish the feasibility of what’s being developed and to ensure that, the prototype must make sure that the product can work well to a purpose. The idea is show that the solution is capable of meeting the business needs[7].

This form of prototyping is good if the product needs to showcase what and why it can be profitable. The prototype must perform good in multiple feasibility aspects, such as technical and financial and that way, it can assure to the client that the prototype would work as a business solution. This form of prototyping would be showing off that the product would prove as a good solution and if the client would want to change any aspect of it.

##### 1.3.3 Horizontal Prototype
The nature of the horizontal prototype is that the scope of the system is defined and gradually builds up detail over time. Functionality is not included in a horizontal prototype as the only main purpose in a horizontal prototype is to showcase the look and the feel of the system, viewing how the unique features fit together[8].

These sorts of prototypes mainly focus on the visual aspect of the product, so it would be hard to test properly due to the lack of function. However, a horizontal prototype can serve as a basis on the look and feel, which gives a better understanding to the product, with how it should act and how it should look like.

##### 1.3.4 Vertical Prototype
Vertical prototypes are used mainly with a technical sense behind them, but their purpose isn’t the entire system but rather a part of it. The system could be anything, but the features that are included and make up that little part of the system are built to a near-complete standard, these features being the ones up for implementation[9].

The whole reason that the vertical prototype is used is to explain what a system does should a specific feature be poorly understood[9]. The level of functionality of this prototype makes it viable to a client should they not understand what a feature does in the prototype as well as to display the components at an early stage or show a working model, making this type prototype good for also showcasing progress as well as explaining the features in a system.

##### 1.3.5 Functional Storyboarding
A storyboard is considered a low fidelity prototype, like a wireframe and created with a paper or pen, but has been used as a medium fidelity prototype, using tools such as Adobe Illustrator or otherwise by giving them highly detailed illustrations. This means that the layout and design of a storyboard to represent a product can be versatile[10].

Prototypes can be used in a variety of ways, to represent a scenario or to design the order of a function, which makes storyboards a widely used method in terms of laying out the basic properties of a product or solution.

### 1.4 Benefits and Drawbacks of End User Testing
##### 1.4.1 Alpha and Beta Testing
The advantages of Beta testing are numerous and can overall ensure an excellent product should said testing be executed well. One such advantage is that its heavily customer based; the customer can test the product which can reduce the chances of product failure and the quality is improved from the customer’s experience. This in turn can create a friendly atmosphere with the customer, improving their experience and satisfaction.
Another advantage is that the company can test the infrastructure post-launch for any bugs past the release and to improve the product[11].

However, as testing is management and control heavy to get reliable results, control surrounding the process of Beta testing is up in the air. Other testing methods are usually done on controlled grounds where the testing can be easily organised, but Beta testing is done by actual people in the real world, meaning that there is minimal control.
Beta testing is also a case of finding the right users for the job, where the users have to match the target audience to which the product is being developed and then it would be a matter if they are interested or not in participating[11].

Alpha testing also has its share of advantages and more so because of how early on its testing is carried out. As testing is carried out so early, the foundations of the software are clear cut, showcasing the reliability of the functions and can help simulate the user behaviour and environment.
Other advantages of Alpha testing are that bugs and serious issues are discovered early on, making the debugging process easier and with due respect to the design and functionality of the product[11]. 

The main disadvantage is since the software is still under development, functionality can’t be tested, which can leave developers or testers unsatisfied with the results. This is in turn can lead to deviation of the software development, due to the testing data clashing with the client’s data[11].
Although useful, alpha testing doesn’t ensure accurate, realistic results due to the environment the software is being tested in, meaning that all the real-world requirements can’t be met properly[12].

##### 1.4.2 Contract and Regulation Testing
Being part of End user acceptance testing, regulation and contract testing both need the product to adhere to set requirements. Within contract testing, the requirements are set out in the contract given specifying the cases within the period of the product going live. 

In regulation testing, the product must adhere to the rules and regulations defined by a country.
One advantage for both testing methods is that it can allow for any issues to be brought to light, highlighting the issues discovered and meaning they ca be fixed before launch. The key advantage in both contract and regulation is that they can be launched once that they have met their requirements. If the product was in contract testing, the requirements predefined means that the development team know what is wanted and can work towards it. In terms of regulation testing, if the product had met all the requirements and broke none of the rules, that product will be able to get released[13].

If in regulation testing that any of the rules and regulations are violated, then the product doesn’t get released, wither resorting to altering it or the product becoming a failure[13]. Contract testing isn’t so straightforward, requiring effective communication when translating the tests but also in maintaining the contracts[14].

##### 1.4.3 Operation Testing
Operational testing can help mainly in terms of ensuring reliable and secure software and have many benefits. Feature interaction can ensure the features of a specific piece of software function clearly and in terms of delivering good user experience, the various aspects of the product are validated before release, that ensures the software working to the best of its abilities.
Software security is taken into consideration with this testing method, by aiding in terms of serious issues that would spring to light with security, such as vulnerabilities in the software, backup and restoration, disaster recovery and maintenance[15].

##### 1.4.4 Black Box
With black box testing, there doesn’t need to be any technical knowhow or programming knowledge; the tester can just be any person. This means that it can aid in developing software more to aid in the product to be more user-friendly, based on what feedback the tester has given. There are no dependencies between the developer or the user, making the testing environment feel less restricted as if it were beta testing and this means that the testing can be completed once the product has been released.

The disadvantages are however, that it is mostly limited in terms of resources and what testing allows; it only allows a certain amount of possible input through the testing phase and if the product has a strict deadline, it wouldn’t be enough to identify and test all the inputs. This sort of testing isn’t recommended if the application is complex and large, as the test coverage, as mentioned before, wouldn’t be fully tested and can leave numerous bugs from test cases[16].

## 2. Tools in Prototyping
Different tools can help create prototypes for distinct reasons and can convey what is needed to be presented to help generate an idea of the product through different means.

##### 2.1 Low Fidelity Tools
Known as Wireframing, there are tools that allow for the creation of this form of prototype. Wireframes mainly are used for basic sketch-ups or an understanding of how the system will work, allowing for extra experimentation and excusing mistakes for improving the design.

Some use pen and paper as a way to draw up wireframe prototypes to create the basic fundamentals of the system or product, mainly because of it being quick and cheap and has no need of any software. However, if you were to refine the prototype, you would have to create a new set of wireframes. Apps like “Balsamiq” can also create wireframes and allow for alterations or even newer versions of the design should improvements be needed. Said app can also be used with other users, thanks to it being primarily cloud based, so they can make changes to the design and offer comments as well.

##### 2.2 Basic Prototyping & Collaboration
Basic Prototyping emulates the features that will be seen in the final product, such as screen linking and interactions. These can be seen as basic wireframes such as before or light mock-ups. With this, there are tools that can help emulate these features effectively, no matter the prototype.

The app “InVision” is a popular tool that allows for basic mock-ups that will suit the needs of the user. The tool allows for colour illustrations and images to be used within the prototype for the amount of detail that will make up more of the detail in the final product, along with animations and interactions for imitating normal interactions that will be seen in the app. The app, like Balsamiq, allows for collaboration, where the users can be fully on board and be notified of changes

##### 2.3 High fidelity prototyping
This sort of prototyping basically mimics the definitive version of the app in terms of design and functionality, representing how the app will work, feel and look to the user. Many tools allow for the creation of near complete prototypes.

UXPin is an app that utilises the features of other prototyping software such as Balsamiq and InVision, with the ability to create fully detailed prototypes and collaboration, but also allows for features such as code that best imitates how the product will function as well as incorporating different components pre-built or from the user themselves.

These prototypes can be created in software engines, such as Unity, to best capture the feel of how the product will function or even look. With this, the prototypes can be modified or re used with incorporation of pre-existing or previous elements, as well as making the development for the final product easier to picture as the features and functions are all demonstrated in the final prototype[6].

## 3. End User Modelling
### 3.1.1 Function
The idea here basically takes organizes the users that understand the system, meaning those that would instinctively know their way around the system. This would fall under the developer’s point of view when developing said program, which could mean those who use certain features for one reason or those who would fully utilize all the features. For instance, a racing game with many features; those who would just like a quick single player game and those who would take advantage of features like tuning the cars or going online.

### 3.1.2 Role
End users via role can help with understanding the program’s audience. The roles of the user can vary but mainly are separated via distinct groups, such as users that would get engaged with the software or viewers who would want entertainment, etc. meaning that roles could prioritize different elements rather than what the developer was originally aiming for.

### 3.1.3 Knowledge/Experience
This would model a prototype based on the users that would have prior knowledge or experience in the system that you would be developing for. This would show various points of design that would cater to that of users that understand what the program is straight away. An example would be developing a first person shooter game, designed for players that have had experience with the features and the type of gameplay that is common in this sort of genre[7].

## 3.2 Behavioural Models
### 3.2.1 Use Case
Use case modelling provides a visual representation of the program’s requirements. They define the interactions between that of the users and the system to define what the main goal of the program will be. In most cases, it describes what the user would do in terms of the interaction of the software. For instance, for a game, it would be the user’s actions such as play game, select level, configure options. With this they can identify what sort of users would be suitable for their program[8][9].

### 3.2.2 Data Driven
Data Driven models detail the sequence of actions, along with the response of the system to the input. Certain UML diagrams can be used to describe data flows, putting emphasis on the data given via an input by the user and can describe the basic processes of what the program does. The diagrams note both the function of the user as well as the admin or the system, detailing the data given based on the inputs of the user[10].

## 3.3 Finding a Methodology for a Project
In the case for my project, “Road Rage”, we would have to find the user that would be considered for the methodology, this way it can pave the way for any future test plans and lay down the requirements for developing the game.

Before gathering the type of user, we would have to understand what the project is. It’s more along the lines to be a racing game with many features that allow for more than one racing type and customization options but can allow for a more relaxed playstyle for casual gamers, thanks to a quick play mode. The users that would be considered first would be more casual users, where they would understand the type of application and would be ready to use it, but haven’t gotten the experience, which would be understandable for the quick race mode of the game. The other users would be for more knowledgeable types, where they would’ve had previous experience in terms of a racing game or games in general and have the skills necessary with this type of application.

In terms of behaviour modelling, we would have to know about what the user would do when playing the game. As stated before, the use case provides the visual representation of a programs requirements and in data driven cases, it details a sequence of actions along with the system’s response. In terms of our game, the behavioural model suitable would be a use case model, where the actions of the game would have to be noted to determine the main goal of the project.

Now comes the point of what methodology would be necessary with both the end user and the behaviour modelling. Evolutionary prototyping would seem to be a fit for the elements above, where the prototype would be built first and the occurring feedback from the users would help refine it until it met the requirements properly. The end users would be ready to test the fundamental elements of the game to ensure it match their requirements and would be ready for the next iteration.

## 4. Methodology relating to end users
### 4.1 Methodology
For this section I will use my project “Road Rage”, a single player project for a college course. Road Rage is a racing game, with features including multiple cars, a car customizer and different race modes.

The target audience I am aiming to achieve here is that of people who enjoy racing games. This end user would fall under the group of what I expect; they would be avid players, meaning that they have had experience with other racing games as well as games in general and to further explain, they must know the fundamental features that makes up racing game. It should also be noted that this must extend to any other user that picks up the game, so if anyone was new to the genre, the game will be designed to make it easy to pick up, by adding features to help the user play the game.

Now to fully test the prototype with this end user, there needs to be the appropriate methodology. Evolutionary prototyping would be more of a suitable method of prototyping with this user for testing. The requirements are best understood with evolutionary, so it should come easy to develop the first prototype. Elements of the incremental prototyping method are used here, such as the prototypes incrementing into the final model, but here they are refined until it is ready to make up the final product[11]. This method gets the user engaged properly, adding feedback to that model until it is to a met standard and carries on at each iteration until it looks like what the requirements said[12].

### 4.2 Methodolgy and Testing Plan
Now that the methodology is chosen, it should be clear that a plan should be in place in terms of developing and testing. Evolutionary prototyping is going to be used for the development of the project and its prototypes. The idea here is to utilise the prototype for the development of the game, by implementing the features first and carefully building it up, with the feedback from the user and applying it to the prototype accordingly.
The features of the prototypes will be carried out first in order to establish the feel of the game, such as the handling of the cars and the inputs, whereas such is the crucial aspect of the game. The game is going to be marketed as an arcade like game where the handling takes aspects from real life but altered to allow for fast driving and intense gameplay, which would work towards the casual users of the game as well as the more experienced ones.
When the handling and over gameplay features are realised, then would be the time to develop the interface of the game. This being the menus, the GUI and other elements of the game. The interactions would be built of off this, making this crucial for the game and the requirements within the behaviour modelling. This would be realised until the next features of the game are developed and tested also.
Then this would culminate into the final prototype, where the game is in a near complete state. The prototype would be sent off to the user where the final elements and the whole game would be tested until that can become the final game.


## 5. Common Tools used for Prototyping
#### 5.1 UXPin
UXPin is a design platform, specializing in designing prototypes, documentation and design systems, mainly those for interfaces, mobile apps and web-based apps. It allows the user to create multiple prototypes all at once and collaborate with other team members to further develop and improve that prototype. It’s more in depth than just designing or establishing a layout, as the user can also have the software mimic the actions that they want it to do. For instance, play an animation when you mouse over a specific element and click to take the user to another part of the prototype. This additional level of detail can make for intricate prototypes where the developer can correctly capture what the final product should look like and feel like[13].

#### 5.2 Balsamiq
Balsamiq is a wireframe prototyping interface builder application designed to create mock-ups and wireframe prototypes to help map out the basic layout of a program or interface. The features included in Balsamiq allow for advanced designing of applications, such as iterations and versions, allowing for different variants of specific designs for feedback and improvements, and collaboration, to create wireframes with other users involved in the project. Cloud based prototyping is also involved, allowing for the user to access their wireframes anywhere[14].

#### 5.3 Unreal Engine
Unreal Engine is a game engine used for a variety of reasons, such as games, product design or virtual reality. Currently, the engine is on its fourth iteration and focusing on realistic or heavily detailed visuals. The engine can be used for developing prototypes and can allow the user to quickly develop them thanks to the tools that unreal has, such as its blueprints function, focused on prototyping and allows users to quickly create the layout of the program or game without ever having to code. Many other features help develop more photorealistic and cinematic looking visuals to give the program a creative visual flair[15].

## 6. Prototype Feedback
### 6.1 Controller Demo
The following prototype was a controller prototype designed for testing out the input that will be used in the final game alongside the keyboard. All the prototype consists is a square shape that can be moved around the canvas. The purpose behind the prototype is to test out the controller input and how well it moves around the screen, to tackle the movement early rather than later and to build the cars that will eventually be controlled in later prototypes and the final game.

As Unity is what I’m developing my game in, this prototype serves to show how well unity can handle controller inputs, mainly the analogue features on the controllers. This prototype also utilises the keyboard movement as to show a “easing input” function, where the input is not instantly to 100% and gradually builds up, offering smooth input on keyboards. This feature will be used for an aspect in controlling the cars. 

![Controller Demo](https://github.com/LBruni98/Prototyping/blob/master/Controller%20Demo.PNG)

The following people that used this prototype are my brother and another class member. They were told to use both of the following control inputs, first the keyboard and then the controller, afterwards returning feedback. 

|Users  |Results|
|-------|-------|
|Dean   |The controller runs well. Where I point it, it goes to that direction on the screen. Keyboard works the same way but is smoother due to how the buttons are. The thing is, I would like to see the controller buttons being used in this sort of way too.|
|Matthew|The demo does make use of the analogue function of the controller and details the movements being accurate to the controller’s inputs; it goes the direction where I point it and depending on the amount of input, it adjusts its speed to match. The keyboard is fluid too, as it functions like the controller but the input wasn't instantaneous rather than fluid. I would like to see this being applied to a scenario related to the game, a car being controlled around a track, so we can see if it works well.|

The feedback both states overall that the controller demo works to the requirements of what I was aiming for. Both users state the controller input was good, with the square going in the direction of where the user had pointed the analogue stick, with the other user reacting positively to the amount of input that can be acted on the analogue stick and applied to the square’s movement. The keyboard controls were also appraised well, stating that the easing function of the keyboard input was smooth and didn’t instantly put the input straight to 100%.

So far for improvement, the problem here that I gathered was that it needed to be applied in a greater sense. The first user commented that the controller demo should be used to support the button presses mainly to see how well they act in the demo. The second user thinks that the controller demo should now be applied to an actual gameplay scenario, where it showcases how a car will behave with this controller input.

Overall, the controller demo had been received positively, stating that the controller functions worked well. However, to fully take advantage of its use would extend its inputs to the buttons of the controller and to actually program it to apply to a car in terms of using the features in an actual game scenario.

### 6.2 Interface Prototypes
The next section of prototypes is for the game’s interface design. Included here are wireframes used to outline the layout of the menus and the HUD elements. These were all developed in the web-based wireframe designer program, Balsamiq, and were all made using the tools the program has given.

The wireframe prototypes to Road Rage can be found [here.](https://github.com/LBruni98/Road-Rage/tree/master/Wireframes)

The prototype’s first iterations were reviewed by the same people who reviewed the controller demo, and both gave their feedback.

|Users  |Results|
|-------|-------|
|Dean   |The menus looked impressive, looking modern and neat. The elements were clear and easy to understand, being that the layout contributed to what part of the game it was meant for. Most of the menus are very good, but the individual aspects would be improved as they look a little basic and could use some additional visual features.|
|Matthew|The menu layouts are well presented and would look good on the final game. It’s neat, well ordered and not confusing at all, should a new player try to get used to the game. The problem being the menu elements, being in some of the menus, they could be improved in order for users not to get lost each menu, such as links greyed out to show what the next page of a certain menu is. For more dynamic visual features, maybe the menu elements should have its position altered to visualise the dynamic interfaces.|

The second iteration took credence to the feedback in relation of the menu element from both users and was applied to certain menus that related to the feedback, giving it more of an ordered and overall easier to navigate layout, whilst trying to keep to the original design.

![Improvement 1](https://github.com/LBruni98/Road-Rage/blob/master/Wireframes/Settings%20Menu(Alternate%20790l).png)

The title screen, which was planned to have a video and visual effects playing in the background, had the title moved so it wouldn’t obstruct the centre of the screen, so to imply what the layout was going to properly look like. Other elements of the wireframe prototypes also received this change in one way or another.

![Improvement 2](https://github.com/LBruni98/Road-Rage/blob/master/Wireframes/Title_screen(Alternate%20807b).png)

|Users  |Results|
|-------|-------|
|Dean   |The menus look nicer as the simple layout matches the original design and looks easier to navigate. It also shows the layout of upcoming dynamic effects that are planned to be used. I want to see this now applied to the other screens that the game will use, like the win screen and reward screen to see how they would look.|
|Matthew|The clearer elements make for better understanding on what the look of the game achieves to be, with some elements that feature more dynamic or visual features altered to support them. The navigation on the menus look like they would be properly comprehended by all sorts of players, meaning that it would be easier to navigate from screen to screen. This should now have a design attached to show what this would look like if it were the final product.|

### References
1. Craig Borysowich (2011). Systems Design: Prototyping. [online]. Toolbox. Available from: <https://it.toolbox.com/blogs/craigborysowich/systems-design-prototyping-081811>. [Accessed 7 October 2018].
2. Muthu Singaram, Prathistha Jain (2018). Types of Prototype and their Usage. [online]. Entrepreneur. Available from: <https://www.entrepreneur.com/article/308724>. [Accessed 7 October 2018].
3. John Spacey (2016). 22 Types of Prototype. [online]. Simplicable. Available from: <https://simplicable.com/new/prototypes>. [Accessed 7 October 2018].
4. Matthew Setter (2015). User Acceptance Testing – How To Do It Right!. [online]. Usersnap. Available from: <https://usersnap.com/blog/user-acceptance-testing-right/>. [Accessed 7 October 2018].
5. Thomas Peham (2015). 5 Types Of User Acceptance Testing. [online]. Usersnap. Available from: <https://usersnap.com/blog/types-user-acceptance-tests-frameworks/>. [Accessed 7 October 2018].
6. Will Fanguy (2018). Wireframing vs. prototyping: What’s the difference?. [online]. Inside Design. Available from: <https://www.invisionapp.com/inside-design/wireframe-prototype-difference/>. [Accessed 17 December 2018].
7. Craig Borysowich (2007). Prototyping: Types of Prototypes. [online]. Toolbox. Available from: <https://it.toolbox.com/blogs/craigborysowich/prototyping-types-of-prototypes-030607>. [Accessed 17 December 2018].
8. Craig Borysowich (2007). Activities for Developing Horizontal. [online]. Toolbox. Available from: <https://it.toolbox.com/blogs/craigborysowich/activities-for-developing-horizontal-amp-vertical-prototypes-091208>. [Accessed 17 December 2018].
9. Usability First [online]. (2010). Available from: <http://www.usabilityfirst.com/glossary/horizontal-and-vertical-prototypes/>. [Accessed 18 December 2018].
10. Joel (2017). Storyboarding vs. Prototyping: When to Use Each. [online]. EnvatoTuts. Available from: <https://webdesign.tutsplus.com/articles/storyboarding-vs-prototyping-when-to-use-each--cms-28707>. [Accessed 18 December 2018].
11. Guru99 [online]. (2013). Available from: <https://www.guru99.com/alpha-beta-testing-demystified.html>. [Accessed 18 December 2018].
12. ProfessionalQA (2017). Storyboarding vs. Prototyping: When to Use Each. [online]. ProfessionalQA. Available from: <http://www.professionalqa.com/alpha-testing>. [Accessed 18 December 2018].
13. Medium (2018). What is Acceptance Testing (A Complete Guide). [online]. Medium. Available from: <https://medium.com/typeforms-engineering-blog/contract-testing-i-e2e-testing-is-so-last-season-1142fa63c740>. [Accessed 18 December 2018].
14. Daniel Giralt Len (2018). Contract Testing (I): E2E testing is SO last season. [online]. Medium. Available from: <https://medium.com/typeforms-engineering-blog/contract-testing-i-e2e-testing-is-so-last-season-1142fa63c740>. [Accessed 18 December 2018].
15. ProfessionalQA (2018). Operational Acceptance Testing or Operational Testing. [online]. ProfessionalQA. Available from: <http://www.professionalqa.com/operational-testing>. [Accessed 18 December 2018].
16. Helping Testers [online]. (2017). Available from: <http://www.helpingtesters.com/black-box-testing/>. [Accessed 18 December 2018].

6. Javier Cuello (2016). How To Choose The Right Prototyping Tool. [online]. Smashing Magazine. Available from: <https://www.smashingmagazine.com/2016/09/choosing-the-right-prototyping-tool/>. [Accessed 7 October 2018].
7. Philosophe [online]. (2009). Available from: <https://philosophe.com/understanding_users/categorizing_users/>. [Accessed 13 December 2018].
8. Radek Silhavy, Petr Silhavy, Zdenka Prokopová (2011). Behavioral modeling in system engineering. Tomas Bata University in Zlin. Available from: <https://www.researchgate.net/publication/228401777_Behavioral_modeling_in_system_engineering>. [Accessed 14 December 2018].
9. Techopedia [online]. (2011). Available from: <https://www.techopedia.com/definition/25813/use-case>. [Accessed 14 December 2018].
10. Behavior Models [online]. (n.d). Available from: <https://gyires.inf.unideb.hu/GyBITT/07/ch03s04.html>. [Accessed 14 December 2018].
11. Sherrell L. (2013) Evolutionary Prototyping. In: Runehov A.L.C., Oviedo L. (eds) Encyclopedia of Sciences and Religions. Springer, Dordrecht. Available from: <https://link.springer.com/referenceworkentry/10.1007/978-1-4020-8265-8_201039>. [Accessed 14 December 2018].
12. Teach-ICT [online]. (2011). Available from: <http://www.teach-ict.com/as_a2_ict_new/ocr/A2_G063/331_systems_cycle/prototyping_RAD/miniweb/pg3.htm>. [Accessed 14 December 2018].
13. UXPin [online]. (2010). Available from: <https://www.uxpin.com/prototyping>. [Accessed 14 December 2018].
14. Balsamiq [online]. (2008). Available from: <https://balsamiq.com/>. [Accessed 15 December 2018].
15. Unreal Engine [online]. (2017). Available from: <https://www.unrealengine.com/en-US/what-is-unreal-engine-4>. [Accessed 15 December 2018].

