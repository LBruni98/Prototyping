# Prototyping

## 1. Prototyping Functionality and End User Requirements

### 1.1 Different Prototypes
A Prototype is a basic version of a product or system, that showcases and demonstrates how the system or product will work. Prototypes within software development are used as a base for the final product, to which it is continuously tested and reworked until a satisfactory prototype is created which the original complete product or system can be developed using this final prototype.

There are many variants of prototypes that are used for different aspects of the development of the initial system, either generating the idea for the product, used for understanding the features contained within the system or as stated above, building off of the prototype to help aid in the final creation of the complete system or product.

##### 1.1.2 Wireframe Prototype
A Wireframe Prototype is where the product is presented as a skeleton. This is done with quick images or illustrations that capture the initial idea of the product, including design, layout and structure.

##### 1.1.3 Feasibility Prototype
A feasibility prototype is created to determine how feasible the various solutions included are and are mainly used to help eliminate most of the technical risks that will come up within development, such as performance, component compatibility, optimization, etc.

##### 1.1.4 Horizontal Prototype
A Horizontal Prototype is a prototype used for showing off a diverse range of features that are planned to be used in the system but not fully implemented the features. These types of prototypes are used for showcasing the range of abilities that are included in a system.

##### 1.1.5 Vertical Prototype
A Vertical Prototype is used only for certain, smaller features that will be used in a system, showcased near-completed.

##### 1.1.6 Functional Storyboarding
A storyboard is used to create an early layout of the product, mainly before the development of the system. This describes the product like a story and presents the information in a readable and more understandable way to that of the development team[2][3].

### 1.2 End User Testing
End User Testing or User Acceptance testing is a phase during the testing of a product where users have a hand in testing the product to help stand up to actual scenarios that the product might face. This testing is crucial before the whole product goes on the market. It is essentially a “real-world” test where the user interacts with the system as normal, investigating the features and find out if there isn’t anything overlooked, left out, understood poorly and such.

The objective of End User Testing is for the product to be able to work alongside day to day life along with regular use, to ensure that the system is up to the business needs[4].

##### 1.2.1 Alpha and Beta Testing
Alpha testing is done normally by the developers during the project’s development, carried out to recognize the bugs and current issues in the system before the initial product is moved out. This type of testing is carried out fairly early in the products lifecycle, near the end of development and before beta testing is carried out. Once the feedback from this testing has been reported, the developers can rework and improve the product for the next cycle or release.

Beta Testing is done via a customer environment, by customers that use the system as if they were going about it regularly. With beta testing, it allows users to fully experience the product and allows for them to locate the issues or bugs that are found in the near complete system. Once tested, the users provide feedback that allows for developers to further improve the product before its release.

##### 1.2.2 Contract Testing
The software in question is tested to a set of criteria and specifications which are agreed upon in a contract. This contract will only result in payment if the requirements that have been specified have been met by the product.

##### 1.2.3 Regulation Testing
With regulation testing, the software is tested against rules and regulations that are defined by the government of a country where the development is being based at and even released. Should the product violate any of these rules and regulations imposed by the country, the product won’t be allowed to use and distribute the product, ultimately deeming it a failure.

##### 1.2.4 Operation Testing
Operation testing is mainly carried out to make sure that implement workflows to ensure the product or system to be used. The workflows tested are for recovery and system backups, training, security and various other workflows to ensure stability of the system before it gets released.

##### 1.2.5 Black Box
Black Box, though functional, can be perceived as end user as well, as these tests share the same properties as End User Testing. This testing is executed to analyse the functionalities of the product or system.

The user doesn’t see the original source code but only the base product. Error reports are noted within the certain categories, outlining missing functions, errors and other issues, etc. This sort of testing is prominent within development because of the equivalents to End User Testing[5].

## 2. Tools in Prototyping
Different tools can help create prototypes for distinct reasons and can convey what is needed to be presented to help generate an idea of the product through different means.

##### 2.1 Low Fidelity Tools
Known as Wireframing, there are tools that allow for the creation of this form of prototype. Wireframes mainly are used for basic sketch-ups or an understanding of how the system will work, allowing for extra experimentation and excusing mistakes for improving the design.

Some use pen and paper as a way to draw up wireframe prototypes to create the basic fundamentals of the system or product, mainly because of it being quick and cheap and has no need of any software. However, if you were to refine the prototype, you would have to create a new set of wireframes. Apps like “Balsamiq” can also create wireframes and allow for alterations or even newer versions of the design should improvements be needed. Said app can also be used with other users, thanks to it being primarily cloud based, so they can make changes to the design and offer comments as well.

##### 2.2 Basic Prototyping & Collaboration
Basic Prototyping emulates the features that will be seen in the final product, such as screen linking and interactions. These can be seen as basic wireframes such as before or light mock-ups. With this, there are tools that can help emulate these features effectively, no matter the prototype.

The app “InVision” is a popular tool that allows for basic mock-ups that will suit the needs of the user. The tool allows for colour illustrations and images to be used within the prototype for the amount of detail that will make up more of the detail in the final product, along with animations and interactions for imitating normal interactions that will be seen in the app. The app, like Balsamiq, allows for collaboration, where the users can be fully on board and be notified of changes

##### 2.3 High fidelity prototyping
This sort of prototyping basically mimics the definitive version of the app in terms of design and functionality, representing how the app will work, feel and look to the user. Many tools allow for the creation of near complete prototypes.

UXPin is an app that utilises the features of other prototyping software such as Balsamiq and InVision, with the ability to create fully detailed prototypes and collaboration, but also allows for features such as code that best imitates how the product will function as well as incorporating different components pre-built or from the user themselves.

These prototypes can be created in software engines, such as Unity, to best capture the feel of how the product will function or even look. With this, the prototypes can be modified or re used with incorporation of pre-existing or previous elements, as well as making the development for the final product easier to picture as the features and functions are all demonstrated in the final prototype[6].

## 3. End User Modelling
### 3.1.1 Function
The idea here basically takes organizes the users that understand the system, meaning those that would instinctively know their way around the system. This would fall under the developer’s point of view when developing said program, which could mean those who use certain features for one reason or those who would fully utilize all the features. For instance, a racing game with many features; those who would just like a quick single player game and those who would take advantage of features like tuning the cars or going online.

### 3.1.2 Role
End users via role can help with understanding the program’s audience. The roles of the user can vary but mainly are separated via distinct groups, such as users that would get engaged with the software or viewers who would want entertainment, etc. meaning that roles could prioritize different elements rather than what the developer was originally aiming for.

### 3.1.3 Knowledge/Experience
This would model a prototype based on the users that would have prior knowledge or experience in the system that you would be developing for. This would show various points of design that would cater to that of users that understand what the program is straight away. An example would be developing a first person shooter game, designed for players that have had experience with the features and the type of gameplay that is common in this sort of genre[7].

## 3.2 Behavioural Models
### 3.2.1 Use Case
Use case modelling provides a visual representation of the program’s requirements. They define the interactions between that of the users and the system to define what the main goal of the program will be. In most cases, it describes what the user would do in terms of the interaction of the software. For instance, for a game, it would be the user’s actions such as play game, select level, configure options. With this they can identify what sort of users would be suitable for their program[8][9].

### 3.2.2 Data Driven
Data Driven models detail the sequence of actions, along with the response of the system to the input. Certain UML diagrams can be used to describe data flows, putting emphasis on the data given via an input by the user and can describe the basic processes of what the program does. The diagrams note both the function of the user as well as the admin or the system, detailing the data given based on the inputs of the user[10].

## 4. Methodolgy relating to end users
For this section I will use my project “Road Rage”, a single player project for a college course. Road Rage is a racing game, with features including multiple cars, a car customizer and different race modes.

The target audience I am aiming to achieve here is that of people who enjoy racing games. This end user would fall under the group of what I expect; they would be avid players, meaning that they have had experience with other racing games as well as games in general and to further explain, they must know the fundamental features that makes up racing game. It should also be noted that this must extend to any other user that picks up the game, so if anyone was new to the genre, the game will be designed to make it easy to pick up, by adding features to help the user play the game.

Now to fully test the prototype with this end user, there needs to be the appropriate methodology. Evolutionary prototyping would be more of a suitable method of prototyping with this user for testing. The requirements are best understood with evolutionary, so it should come easy to develop the first prototype. Elements of the incremental prototyping method are used here, such as the prototypes incrementing into the final model, but here they are refined until it is ready to make up the final product[11]. This method gets the user engaged properly, adding feedback to that model until it is to a met standard and carries on at each iteration until it looks like what the requirements said[12].

## 5. Tools used for Prototyping
#### 5.1 UXPin
UXPin is a design platform, specializing in designing prototypes, documentation and design systems, mainly those for interfaces, mobile apps and web-based apps. It allows the user to create multiple prototypes all at once and collaborate with other team members to further develop and improve that prototype. It’s more in depth than just designing or establishing a layout, as the user can also have the software mimic the actions that they want it to do. For instance, play an animation when you mouse over a specific element and click to take the user to another part of the prototype. This additional level of detail can make for intricate prototypes where the developer can correctly capture what the final product should look like and feel like[13].

#### 5.2 Balsamiq

#### 5.3 Unreal Engine

### References
1. Craig Borysowich (2011). Systems Design: Prototyping. [online]. Toolbox. Available from: <https://it.toolbox.com/blogs/craigborysowich/systems-design-prototyping-081811>. [Accessed 7 October 2018].
2. Muthu Singaram, Prathistha Jain (2018). Types of Prototype and their Usage. [online]. Entrepreneur. Available from: <https://www.entrepreneur.com/article/308724>. [Accessed 7 October 2018].
3. John Spacey (2016). 22 Types of Prototype. [online]. Simplicable. Available from: <https://simplicable.com/new/prototypes>. [Accessed 7 October 2018].
4. Matthew Setter (2015). User Acceptance Testing – How To Do It Right!. [online]. Usersnap. Available from: <https://usersnap.com/blog/user-acceptance-testing-right/>. [Accessed 7 October 2018].
5. Thomas Peham (2015). 5 Types Of User Acceptance Testing. [online]. Usersnap. Available from: <https://usersnap.com/blog/types-user-acceptance-tests-frameworks/>. [Accessed 7 October 2018].
6. Javier Cuello (2016). How To Choose The Right Prototyping Tool. [online]. Smashing Magazine. Available from: <https://www.smashingmagazine.com/2016/09/choosing-the-right-prototyping-tool/>. [Accessed 7 October 2018].
7. Philosophe [online]. (2009). Available from: <https://philosophe.com/understanding_users/categorizing_users/>. [Accessed 13 December 2018].
8. Radek Silhavy, Petr Silhavy, Zdenka Prokopová (2011). Behavioral modeling in system engineering. Tomas Bata University in Zlin. Available from: <https://www.researchgate.net/publication/228401777_Behavioral_modeling_in_system_engineering>. [Accessed 14 December 2018].
9. Techopedia [online]. (2011). Available from: <https://www.techopedia.com/definition/25813/use-case>. [Accessed 14 December 2018].
10. Behavior Models [online]. (n.d). Available from: <https://gyires.inf.unideb.hu/GyBITT/07/ch03s04.html>. [Accessed 14 December 2018].
11. Sherrell L. (2013) Evolutionary Prototyping. In: Runehov A.L.C., Oviedo L. (eds) Encyclopedia of Sciences and Religions. Springer, Dordrecht. Available from: <https://link.springer.com/referenceworkentry/10.1007/978-1-4020-8265-8_201039>. [Accessed 14 December 2018].
12. Teach-ICT [online]. (2011). Available from: <http://www.teach-ict.com/as_a2_ict_new/ocr/A2_G063/331_systems_cycle/prototyping_RAD/miniweb/pg3.htm>. [Accessed 14 December 2018].
13. UXPin [online]. (2010). Available from: <https://www.uxpin.com/prototyping>. [Accessed 14 December 2018].
14.
